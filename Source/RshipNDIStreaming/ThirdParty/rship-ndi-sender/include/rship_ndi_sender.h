/*
 * rship_ndi_sender.h
 *
 * C FFI header for the Rust NDI sender library.
 *
 * This file is auto-generated by cbindgen when you build the Rust library:
 *   cd Plugins/RshipNDIStreaming/Source/RshipNDIStreaming/ThirdParty/rship-ndi-sender
 *   cargo build --release
 *
 * IMPORTANT: This is a placeholder that allows compilation before the Rust library
 * is built. The real header will be generated by cbindgen during cargo build.
 */

#ifndef RSHIP_NDI_SENDER_H
#define RSHIP_NDI_SENDER_H

#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Opaque handle to the NDI sender.
 */
typedef struct RshipNDISender RshipNDISender;

/**
 * Frame data passed from C++ (Unreal Engine).
 */
typedef struct RshipNDIFrame {
    /** Pointer to RGBA pixel data (must remain valid during call) */
    const uint8_t *data;
    /** Size of data in bytes (width * height * 4 for RGBA) */
    size_t data_size;
    /** Frame width in pixels */
    int32_t width;
    /** Frame height in pixels */
    int32_t height;
    /** Frame number for ordering/debugging */
    int64_t frame_number;
    /** Timestamp in 100-nanosecond units (NDI timecode format) */
    int64_t timestamp_100ns;
} RshipNDIFrame;

/**
 * Configuration for NDI sender.
 */
typedef struct RshipNDIConfig {
    /** Stream name visible on network (null-terminated UTF-8) */
    const char *stream_name;
    /** Frame width in pixels */
    int32_t width;
    /** Frame height in pixels */
    int32_t height;
    /** Target framerate numerator (e.g., 60 for 60fps) */
    int32_t framerate_num;
    /** Target framerate denominator (e.g., 1 for 60fps) */
    int32_t framerate_den;
    /** Enable alpha channel (RGBA vs RGBX) */
    bool enable_alpha;
    /** Number of frame buffer slots (2-4, default 3) */
    int32_t buffer_count;
} RshipNDIConfig;

/**
 * Statistics returned to C++.
 */
typedef struct RshipNDIStats {
    /** Total frames successfully sent */
    uint64_t frames_sent;
    /** Frames dropped due to queue full */
    uint64_t frames_dropped;
    /** Average time to send a frame in microseconds */
    double avg_send_time_us;
    /** Number of connected NDI receivers */
    int32_t connected_receivers;
    /** Whether the sender is healthy and running */
    bool is_healthy;
    /** Current queue depth (frames waiting to send) */
    int32_t queue_depth;
} RshipNDIStats;

/**
 * Create a new NDI sender.
 *
 * @param config Pointer to configuration struct
 * @return Opaque pointer to sender, or NULL on failure
 */
RshipNDISender *rship_ndi_create(const RshipNDIConfig *config);

/**
 * Destroy an NDI sender and release all resources.
 *
 * @param sender Sender handle from rship_ndi_create
 */
void rship_ndi_destroy(RshipNDISender *sender);

/**
 * Submit a frame for NDI transmission.
 *
 * This function is non-blocking. If the internal queue is full,
 * the frame is dropped and the function returns false.
 *
 * @param sender Sender handle from rship_ndi_create
 * @param frame Pointer to frame data struct
 * @return true if frame was accepted for transmission, false if dropped
 */
bool rship_ndi_submit_frame(RshipNDISender *sender, const RshipNDIFrame *frame);

/**
 * Get current statistics from the sender.
 *
 * @param sender Sender handle
 * @param stats Output statistics struct
 */
void rship_ndi_get_stats(const RshipNDISender *sender, RshipNDIStats *stats);

/**
 * Check if the NDI library is available on this system.
 *
 * @return true if NDI runtime is installed and accessible
 */
bool rship_ndi_is_available(void);

#ifdef __cplusplus
}
#endif

#endif /* RSHIP_NDI_SENDER_H */
